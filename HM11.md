# Домашнее задание к занятию "6.6. Troubleshooting"

---
## Задача 1

<details><summary></summary>

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

</details>

## Решение 1

 - Для поиска зависших запросов можно использовать данную команду:

```js
db.currentOp().inprog.forEach(function (op) {
  if (op.secs_running > 50) printjson(op);
});
```

 - Для остановки запроса по полученому `opid` из предыдущей команды можно использовать:
 
```js
 db.killOp();
```

---
## Задача 2
    
<details><summary></summary>

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
 
</details>

## Решение 2

Вероятно проблема может быть с истекшими ключами оставшимися в памяти.  
Если колличество истекших ключей более 25% от общего чила то при их очистке могут возникать задержки.  
Basically this means that if the database has many many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.

## Задача 3
    
<details><summary></summary>


Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

</details>

## Решение 3

Данная ошибка c долгой обработкой запроса в `MySQL` и поисчению таймаута происходит обрыв соединения.  
Решению данной проблемы могут посодействовать различные дествия:  
 - Увеличения времени непосредственно самого таймаута запроса  
 - Мониторинг и увеличение ресурсов сервера что напрямую повлияет на быстродействие
 - Создание индексов и шардирование таблиц для оптимизации работы запросов БД

## Задача 4
    
<details><summary></summary>


Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

 </details>

## Решение 4

Процесс `OOM-Killer` ответственнен за поддержание работоспособности сервера в целом, и при нехватке системных ресурсов пытается остановить процессы занимающие большую чать памяти.  

Если причина увеличения памяти связана напрямую с PostgreSQL тогда можно смаштабировать память используя такие значения как:

`shared_buffers`  
Объём совместно используемой памяти, выделяемой PostgreSQL для кэширования данных, определяется числом страниц (shared_buffers) по 8 килобайт каждая. Следует учитывать, что операционная система сама кеширует данные, поэтому нет необходимости отводить под кэш всю наличную оперативную память.  

`temp_buffers`  
Задаёт максимальный объём памяти, выделяемой для временных буферов в каждом сеансе.  
 
`work_mem`  
Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске.  
 
Что касается непосредственного самой ОС если проблема не связана с банальной нехваткой ресурсов тогда:  

Можно использовать `vm.overcommit_memory` он может иметь одно из трёх значений:  

```
0: ядро может выделить больше виртуальной памяти, чем доступно реально, но при этом полагается на “эвристический алгоритм” (heuristic overcommit handling) при принятии решения о выделении или об отказе  
1: ядро всегда будет выполнять overcommit, что увеличивает вероятность ошибок Out of memory, но должно позитивно влиять на производительность процессов, активно использующих память  
2: ядро не будет выделять памяти больше, чем определено в overcommit_ratio или overcommit_kbytes  
vm.overcommit_ratio — процент оперативной памяти, доступной для чрезмерной загрузки.  
```

Та же можно настроить swap: указать в параметре vm.swappiness значение побольше (по-умолчанию = 60), чтобы ядро начало использовать swap раньше.  
